---
description: Generate the complete /docs suite using parallel background agents that write directly to files, keeping orchestrator context minimal.
allowed-tools:
  - Read
  - Glob
  - Grep
  - Write
  - Edit
  - Task
  - TaskOutput
  - Bash
---

# Generate Complete Documentation Suite

You are the orchestrator. You MUST use background agents to keep context minimal and enable parallel generation.

## Core Principle: Parallel Background Agents

**The orchestrator NEVER receives doc content.** All content is generated by background agents that write directly to files, keeping orchestrator context minimal (~2,000 lines vs ~15,000 lines in sequential approach).

**Key Architecture:**
- 11 diagram agents (parallel)
- 10 doc agents (parallel)
- Total: 21 agents working simultaneously

**Context Efficiency:** 93% reduction in orchestrator context vs sequential generation.

**Note:** Review is handled separately via `/review-docs` command after generation completes.

---

## Workflow: Execute ALL Phases Sequentially

**‚ö†Ô∏è CRITICAL: You MUST execute ALL phases below in order. DO NOT skip any phase.**

**Complete Phase List:**
1. **Phase 0:** Check Existing Docs & Get User Choice
2. **Phase 1:** Extract Global Constraints
3. **Phase 2:** Generate Diagrams (11 parallel agents)
4. **Phase 2.5:** VALIDATE Diagrams (validation gate - all 11 must exist)
5. **Phase 3:** Generate Docs (10 parallel agents)
6. **Phase 3.5:** WAIT for ALL Agents to Complete (CRITICAL - synchronization gate)
7. **Phase 4:** Validate Generated Files
8. **Phase 5:** Generate Navigation Docs (README.md, CHANGELOG.md)
9. **Phase 6:** Cleanup

**Note:** Review is now a separate command (`/review-docs`) run after generation completes.

Each phase is detailed below with complete instructions.

### Phase 0: Check Existing Docs & Get User Choice

**Before starting generation:**

1. **Scan docs/generated/ for existing docs**
   ```bash
   ls -la docs/generated/*.md
   ```

2. **Display found docs with details**
   ```
   Found existing documentation:
   ‚úÖ ARCHITECTURE.md (2,917 lines, 89 KB)
   ‚úÖ DATABASE.md (1,234 lines, 45 KB)
   ‚ùå API.md (not found)
   ...
   ```

3. **Present options to user using AskUserQuestion:**
   ```
   Question: "What should I do with existing documentation?"

   Options:
   - "Skip existing, generate only missing docs" (Recommended)
   - "Regenerate all (fresh start)"
   - "Let me choose specific docs to regenerate"
   ```

4. **Process user choice:**
   - Option 1: Filter doc list to only missing docs
   - Option 2: Delete docs/generated/*.md, proceed with full list
   - Option 3: Present follow-up with checkboxes

### Phase 1: Extract Global Constraints

1. **Read architectural authorities:**
   - docs/target/system-vision.md
   - docs/target/architecture.md

2. **Extract GLOBAL CONSTRAINTS** (max 100 lines):
   - System name, tech stack
   - Key architectural patterns
   - Naming conventions
   - Immutable invariants
   - Engine vs Lens boundaries

3. **Write to shared file** for background agents:
   ```
   Write to: .claude/tmp/global_constraints.md
   ```

### Phase 2: Generate Diagrams (Parallel Background Agents)

**‚ö†Ô∏è MANDATORY PHASE - DO NOT SKIP**

**ALL Required Diagrams (11 total - industry standard best practices):**

1. `pipeline.mmd` ‚Äî 11-stage data flow (Input ‚Üí Entity Store)
2. `architecture.mmd` ‚Äî Engine vs Lens layers, component interaction
3. `entity_model.mmd` ‚Äî Entity schema ER diagram (classes, dimensions, modules)
4. `c4.mmd` ‚Äî C4 model context diagram (system boundaries, external actors)
5. `component.mmd` ‚Äî Component diagram (internal module dependencies)
6. `sequence.mmd` ‚Äî Sequence diagram (key workflows like query execution)
7. `state.mmd` ‚Äî State diagram (entity lifecycle, pipeline states)
8. `deployment.mmd` ‚Äî Deployment diagram (infrastructure, hosting)
9. `dependency.mmd` ‚Äî Dependency graph (module/package dependencies)
10. `network.mmd` ‚Äî Network diagram (API boundaries, data flows)
11. `user_journey.mmd` ‚Äî User journey map (developer onboarding, query flow)

**Generate ALL diagrams using parallel background agents** (same pattern as doc generation):

```python
# Single message with multiple Task calls - ALL diagrams in parallel
Task(
  subagent_type="general-purpose",
  description="Generate pipeline diagram",
  prompt="""
You are generating the pipeline.mmd diagram.

1. Read GLOBAL CONSTRAINTS from .claude/tmp/global_constraints.md
2. Read docs/target/architecture.md Section 4.1 (Pipeline Stages)
3. Generate comprehensive Mermaid graph showing all 11 stages
4. Write to docs/generated/diagrams/pipeline.mmd
5. Return brief confirmation (<50 lines)

Include: Input, Lens Resolution, Planning, Connector Execution, Raw Ingestion,
Source Extraction, Lens Application, Classification, Deduplication, Merge, Finalization
  """,
  run_in_background=True
)

Task(
  subagent_type="general-purpose",
  description="Generate architecture diagram",
  prompt="""
You are generating the architecture.mmd diagram.

1. Read GLOBAL CONSTRAINTS from .claude/tmp/global_constraints.md
2. Read docs/target/system-vision.md Section 3 (Architectural Boundaries)
3. Generate Mermaid diagram showing Engine vs Lens separation with all layers
4. Write to docs/generated/diagrams/architecture.mmd
5. Return brief confirmation (<50 lines)

Show: Applications Layer, Engine Layer (6 subsystems), Lens Layer, Data Storage, External Sources
  """,
  run_in_background=True
)

# ... Repeat for ALL 11 diagrams
```

**Track ALL diagram agents:**
```json
{
  "pipeline": {"agent_id": "task_1", "output_file": "<from_task_result>"},
  "architecture": {"agent_id": "task_2", "output_file": "<from_task_result>"},
  "entity_model": {"agent_id": "task_3", "output_file": "<from_task_result>"},
  "c4": {"agent_id": "task_4", "output_file": "<from_task_result>"},
  "component": {"agent_id": "task_5", "output_file": "<from_task_result>"},
  "sequence": {"agent_id": "task_6", "output_file": "<from_task_result>"},
  "state": {"agent_id": "task_7", "output_file": "<from_task_result>"},
  "deployment": {"agent_id": "task_8", "output_file": "<from_task_result>"},
  "dependency": {"agent_id": "task_9", "output_file": "<from_task_result>"},
  "network": {"agent_id": "task_10", "output_file": "<from_task_result>"},
  "user_journey": {"agent_id": "task_11", "output_file": "<from_task_result>"}
}
```

**Monitor completion:**
```bash
# Poll each output file periodically
tail -n 20 <output_file_for_pipeline>  # Check if "‚úÖ Complete" appears
tail -n 20 <output_file_for_architecture>
# ... for all 11 diagrams
```

**Wait for ALL diagram agents to complete** before proceeding to Phase 2.5

### Phase 2.5: VALIDATION GATE - Verify ALL Diagrams Exist

**CRITICAL: This gate MUST pass before proceeding to Phase 3**

```bash
# Verify ALL 11 required diagrams exist
required_diagrams=(
  "docs/generated/diagrams/pipeline.mmd"
  "docs/generated/diagrams/architecture.mmd"
  "docs/generated/diagrams/entity_model.mmd"
  "docs/generated/diagrams/c4.mmd"
  "docs/generated/diagrams/component.mmd"
  "docs/generated/diagrams/sequence.mmd"
  "docs/generated/diagrams/state.mmd"
  "docs/generated/diagrams/deployment.mmd"
  "docs/generated/diagrams/dependency.mmd"
  "docs/generated/diagrams/network.mmd"
  "docs/generated/diagrams/user_journey.mmd"
)

missing_count=0
for diagram in "${required_diagrams[@]}"; do
  if [[ ! -f "$diagram" ]]; then
    echo "‚ùå MISSING: $diagram"
    ((missing_count++))
  else
    echo "‚úÖ FOUND: $diagram"
  fi
done

if [[ $missing_count -gt 0 ]]; then
  echo ""
  echo "‚ùå VALIDATION FAILED: $missing_count diagrams missing"
  echo "Cannot proceed to Phase 3 without ALL diagrams"
  exit 1
fi

echo ""
echo "‚úÖ All 11 required diagrams verified"
```

**If validation fails:**
1. STOP execution immediately
2. Report which diagrams are missing (see output above)
3. DO NOT proceed to Phase 3
4. Fix Phase 2 diagram generation (re-spawn failed agents)

**Only proceed to Phase 3 if ALL 11 diagrams pass validation.**

### Phase 3: Generate Docs (Parallel)

**Document List:**
1. ARCHITECTURE.md
2. DATABASE.md
3. API.md
4. FEATURES.md
5. ONBOARDING.md
6. FRONTEND.md
7. BACKEND.md
8. DEPLOYMENT.md
9. DEVELOPMENT.md
10. CONFIGURATION.md

**For each doc in FILTERED list (from Phase 0):**

#### Step 3a: Spawn Background Agent

**Single message with multiple Task calls** (one per doc):

```python
# Parallel doc generation
Task(
  subagent_type="general-purpose",
  description=f"Generate ARCHITECTURE.md",
  prompt=f"""
You are a background agent generating ARCHITECTURE.md.

## Instructions

1. Read GLOBAL CONSTRAINTS from .claude/tmp/global_constraints.md
2. Read required diagrams:
   - docs/generated/diagrams/diagram_architecture.mmd
   - docs/generated/diagrams/diagram_c4.mmd
   - docs/generated/diagrams/diagram_dependency.mmd
   - docs/generated/diagrams/diagram_sequence.mmd

3. Read source files to understand architecture:
   - docs/target/system-vision.md
   - docs/target/architecture.md
   - engine/orchestration/
   - engine/ingestion/
   - engine/extraction/
   - engine/lenses/

4. Generate complete ARCHITECTURE.md following the outline‚Üísection-chunks pattern:
   a. Create outline (sections)
   b. Write skeleton to docs/generated/ARCHITECTURE.md
   c. For each section:
      - Generate content (‚â§400 lines)
      - Edit file to insert content
      - Continue to next section

5. Embed diagrams using: ```mermaid\n[diagram content]\n```

6. Follow GLOBAL CONSTRAINTS for all naming and terminology

7. When complete, return concise confirmation (see _shared-direct-write-pattern.md)

## Important
- Write directly to docs/generated/ARCHITECTURE.md
- DO NOT return content to orchestrator
- Keep your final message under 50 lines
  """,
  run_in_background=True
)

# Repeat for all 10 docs in parallel
Task(subagent="general-purpose", description="Generate DATABASE.md", prompt="...", run_in_background=True)
Task(subagent="general-purpose", description="Generate API.md", prompt="...", run_in_background=True)
...
```

**Track agents (capture output_file from task results):**
```json
{
  "ARCHITECTURE.md": {"agent_id": "task_10", "output_file": "<path_from_task_result>"},
  "DATABASE.md": {"agent_id": "task_11", "output_file": "<path_from_task_result>"},
  ...
}
```

**Note:** The `output_file` paths are returned by the Task tool and may vary by system.

#### Step 3b: Monitor Progress

**Poll output files periodically using paths from task results:**

```bash
# Every 30 seconds, check all agent output files using captured paths
tail -n 20 <output_file_for_architecture>  # Look for "‚úÖ Section complete" or "‚úÖ Complete"
tail -n 20 <output_file_for_database>
...
```

**Display progress to user:**
```
üìä Doc Generation Progress (10 agents running in parallel)

‚úÖ ARCHITECTURE.md - Complete (2,456 lines)
‚úÖ DATABASE.md - Complete (1,123 lines)
‚è≥ API.md - Section 4/7 in progress
‚è≥ FEATURES.md - Section 2/5 in progress
‚è≥ ONBOARDING.md - Generating outline
‚è≥ FRONTEND.md - Section 1/6 in progress
‚è≥ BACKEND.md - Section 3/8 in progress
‚è≥ DEPLOYMENT.md - Section 2/4 in progress
‚è≥ DEVELOPMENT.md - Generating outline
‚è≥ CONFIGURATION.md - Section 1/3 in progress
```

#### Step 3c: Track Agent Metadata

**CRITICAL: Store agent tracking information for Phase 3.5:**

```python
doc_agents = []
for doc_name, task_result in [("ARCHITECTURE.md", task_10), ("DATABASE.md", task_11), ...]:
    doc_agents.append({
        "doc": doc_name,
        "agent_id": task_result.agent_id,
        "output_file": task_result.output_file,
        "status": "running"
    })
```

**DO NOT proceed to Phase 3.5 until you have captured ALL agent metadata.**

### Phase 3.5: WAIT for ALL Agents to Complete (CRITICAL SYNCHRONIZATION GATE)

**‚ö†Ô∏è THIS IS THE MOST CRITICAL PHASE - DO NOT SKIP OR RUSH**

This phase ensures the orchestrator NEVER declares completion before all agents finish.

**Step 1: Display Waiting Message**

```
‚è≥ Waiting for all doc agents to complete...
Tracking {len(doc_agents)} agents

This may take 3-5 minutes. Progress will be shown below.
```

**Step 2: Sequential Completion Waiting**

**CRITICAL:** Use `TaskOutput(block=True)` to wait for EACH agent sequentially:

```python
print("\n‚è≥ Waiting for all doc agents to complete...")
print(f"Tracking {len(doc_agents)} agents\n")

for i, agent in enumerate(doc_agents):
    print(f"[{i+1}/{len(doc_agents)}] Waiting for {agent['doc']}...")

    # BLOCKING WAIT - do not proceed until this agent completes
    result = TaskOutput(
        task_id=agent['agent_id'],
        block=True,
        timeout=600000  # 10 minutes max
    )

    agent['status'] = 'complete'

    # Verify file was written
    file_path = f"docs/generated/{agent['doc']}"
    if os.path.exists(file_path):
        line_count = len(open(file_path).readlines())
        print(f"  ‚úÖ {agent['doc']} complete ({line_count} lines)\n")
    else:
        print(f"  ‚ö†Ô∏è {agent['doc']} complete but file not found\n")

print("\n‚úÖ All agents complete. Proceeding to validation...\n")
```

**Step 3: Display Live Progress to User**

Example output the user will see:

```
‚è≥ Waiting for all doc agents to complete...
Tracking 10 agents

[1/10] Waiting for ARCHITECTURE.md...
  ‚úÖ ARCHITECTURE.md complete (2,456 lines)

[2/10] Waiting for DATABASE.md...
  ‚úÖ DATABASE.md complete (1,123 lines)

[3/10] Waiting for API.md...
  ‚úÖ API.md complete (987 lines)

[4/10] Waiting for FEATURES.md...
  ‚úÖ FEATURES.md complete (1,234 lines)

[5/10] Waiting for ONBOARDING.md...
  ‚úÖ ONBOARDING.md complete (756 lines)

[6/10] Waiting for FRONTEND.md...
  ‚úÖ FRONTEND.md complete (1,098 lines)

[7/10] Waiting for BACKEND.md...
  ‚úÖ BACKEND.md complete (1,567 lines)

[8/10] Waiting for DEPLOYMENT.md...
  ‚úÖ DEPLOYMENT.md complete (654 lines)

[9/10] Waiting for DEVELOPMENT.md...
  ‚úÖ DEVELOPMENT.md complete (892 lines)

[10/10] Waiting for CONFIGURATION.md...
  ‚úÖ CONFIGURATION.md complete (445 lines)

‚úÖ All agents complete. Proceeding to validation...
```

**Step 4: Error Handling**

If an agent times out or fails:

```python
try:
    result = TaskOutput(task_id=agent['agent_id'], block=True, timeout=600000)
    agent['status'] = 'complete'
except TimeoutError:
    print(f"  ‚ö†Ô∏è {agent['doc']} TIMED OUT after 10 minutes")
    agent['status'] = 'timeout'
    # Continue waiting for other agents
except Exception as e:
    print(f"  ‚ùå {agent['doc']} FAILED: {e}")
    agent['status'] = 'failed'
    # Continue waiting for other agents
```

**Step 5: Final Verification**

After waiting for all agents, verify completion status:

```python
complete_count = sum(1 for a in doc_agents if a['status'] == 'complete')
timeout_count = sum(1 for a in doc_agents if a['status'] == 'timeout')
failed_count = sum(1 for a in doc_agents if a['status'] == 'failed')

print(f"\nüìä Agent Completion Summary:")
print(f"  ‚úÖ Complete: {complete_count}/{len(doc_agents)}")
if timeout_count > 0:
    print(f"  ‚è±Ô∏è Timeout: {timeout_count}")
if failed_count > 0:
    print(f"  ‚ùå Failed: {failed_count}")
```

**ONLY AFTER THIS PHASE MAY YOU PROCEED TO PHASE 4 (VALIDATION).**

**Why This Phase Is Critical:**

1. **Prevents premature "complete" messages** - User knows exactly when work is done
2. **Enables proper error handling** - Timeouts and failures are caught and reported
3. **Provides clear progress** - User sees live updates as each agent finishes
4. **Prevents incomplete docs** - Validation only runs after ALL agents finish
5. **Eliminates confusion** - No background messages after "complete" declaration

### Phase 4: Validate Generated Files

**For each doc:**

1. **Check file exists:**
   ```bash
   ls -lh docs/generated/ARCHITECTURE.md
   ```

2. **Verify content (lightweight check):**
   ```bash
   wc -l docs/generated/ARCHITECTURE.md  # Line count
   grep "^#" docs/generated/ARCHITECTURE.md | head -20  # Section headings
   ```

3. **Track validation results:**
   ```json
   {
     "ARCHITECTURE.md": {"exists": true, "lines": 2456, "sections": 12},
     "DATABASE.md": {"exists": true, "lines": 1123, "sections": 8},
     ...
   }
   ```

**If file missing or suspiciously small:**
```
‚ö†Ô∏è DATABASE.md validation failed (only 23 lines)
Reading agent output to diagnose...
[tail <output_file_agent_11.log]

Issue: [describe problem]
Options:
1. Retry this doc
2. Continue with other docs
3. Abort
```

### Phase 5: Generate Navigation Docs

**Generate README.md and CHANGELOG.md** (orchestrator does this directly):

1. **README.md:**
   ```markdown
   # Generated Documentation Suite

   Generated on: [timestamp]

   ## Documents
   - [ARCHITECTURE.md](ARCHITECTURE.md) - System architecture (2,456 lines)
   - [DATABASE.md](DATABASE.md) - Database schema (1,123 lines)
   ...

   ## Generation Stats
   - Total lines: 12,345
   - Docs generated: 10
   - Diagrams embedded: 11 (all industry standards)
   - Generation time: ~6-7 minutes (parallel)
   - Agents used: 42 total (11 diagram + 11 diagram review + 10 doc + 10 doc review)
   ```

2. **CHANGELOG.md:**
   ```markdown
   # Documentation Generation Changelog

   ## Generation: 2026-02-08 14:32

   ### Strategy
   - Mode: Parallel background agents
   - Docs generated: 10
   - Time: 3.5 minutes

   ### Agent Details
   - Diagram generation: 11 (parallel)
   - Diagram review: 11 (parallel)
   - Doc generation: 10 (parallel)
   - Doc review: 10 (parallel)
   - Total: 42 agents

   ### Files Created
   - docs/generated/ARCHITECTURE.md (2,456 lines)
   - docs/generated/DATABASE.md (1,123 lines)
   ...

   ### Review Summary
   - Blocking issues: 0
   - Important issues: 3 (applied automatically)
   - Minor issues: 7 (applied automatically)

   ### Context Efficiency
   - Orchestrator peak context: ~1,800 lines
   - vs. Sequential approach: ~15,000 lines
   - Reduction: 88%
   ```

### Phase 6: Cleanup

**Remove temporary files:**
```bash
rm .claude/tmp/global_constraints.md
rm docs/generated/diagrams/diagram_*.mmd
# Note: agent log files are system-managed and cleaned automatically
```

### Final Output

```
‚úÖ Documentation Generation Complete

Strategy: Parallel background agents
Time: 3-4 minutes
Agents: 21 total (11 diagram + 10 doc)

Files Generated:
‚úÖ docs/generated/ARCHITECTURE.md (2,456 lines, 78 KB)
‚úÖ docs/generated/DATABASE.md (1,123 lines, 42 KB)
‚úÖ docs/generated/API.md (987 lines, 35 KB)
‚úÖ docs/generated/FEATURES.md (1,234 lines, 45 KB)
‚úÖ docs/generated/ONBOARDING.md (756 lines, 28 KB)
‚úÖ docs/generated/FRONTEND.md (1,098 lines, 39 KB)
‚úÖ docs/generated/BACKEND.md (1,567 lines, 52 KB)
‚úÖ docs/generated/DEPLOYMENT.md (654 lines, 24 KB)
‚úÖ docs/generated/DEVELOPMENT.md (892 lines, 31 KB)
‚úÖ docs/generated/CONFIGURATION.md (445 lines, 16 KB)
‚úÖ docs/generated/README.md (navigation)
‚úÖ docs/generated/CHANGELOG.md (generation log)

Total: 11,212 lines across 12 files

Diagrams:
‚úÖ All 11 industry-standard diagrams generated and embedded
  (pipeline, architecture, entity_model, c4, component, sequence,
   state, deployment, dependency, network, user_journey)

Context Efficiency:
- Orchestrator peak: ~1,500 lines
- vs. Sequential: ~15,000 lines
- Improvement: 90% reduction

Next Steps:
- Review generated docs in docs/generated/
- Run /review-docs to review and fix quality issues (optional)
- Move to docs/ root when approved
- Run /update-docs for incremental changes
```

## Agent Mapping

**Diagram Generation Agents (Phase 2 - ALL 11 required):**
1. pipeline ‚Äî 11-stage data flow visualization
2. architecture ‚Äî Engine vs Lens layers with all components
3. entity_model ‚Äî Entity schema ER diagram
4. c4 ‚Äî C4 model context diagram (system boundaries)
5. component ‚Äî Component diagram (internal dependencies)
6. sequence ‚Äî Sequence diagram (key workflows)
7. state ‚Äî State diagram (entity lifecycle, pipeline states)
8. deployment ‚Äî Deployment diagram (infrastructure)
9. dependency ‚Äî Dependency graph (module/package dependencies)
10. network ‚Äî Network diagram (API boundaries, data flows)
11. user_journey ‚Äî User journey map (developer flows)

**Doc Generation Agents (Phase 3 - ALL 10 required):**
- Each doc gets its own general-purpose agent
- Agent reads sources, generates content, writes directly to file
- Returns brief (<50 line) confirmation

**Review (Separate Command):**
- Review is now handled by `/review-docs` command
- Runs independently after generation completes
- Prevents context bloat in generation workflow

## Error Handling

**If agent fails:**
1. Read agent output file: `Read(<output_file_agent_X.log)`
2. Diagnose issue from agent's messages
3. Options:
   - Retry with clearer prompt
   - Skip this doc (continue with others)
   - Abort entire generation

**If agent timeout (>10 min):**
```
‚ö†Ô∏è Agent task_15 (BACKEND.md) timed out after 10 minutes

Options:
1. Extend timeout and continue waiting
2. Terminate and retry with simpler sections
3. Skip this doc
```

**If validation fails:**
```
‚ö†Ô∏è FEATURES.md validation failed
- Expected >500 lines, got 87 lines
- Missing sections: User Journeys, Integration Examples

Reading agent output...
[diagnosis]

Options:
1. Retry generation
2. Manual inspection needed
3. Continue with other docs
```

## Performance Comparison

| Metric | Sequential (v3) | Parallel (v4) | Parallel (v5 - current) | Improvement |
|--------|----------------|---------------|-------------------------|-------------|
| Time | ~25 minutes | ~4 minutes | ~3 minutes | 88% faster |
| Orchestrator context | ~15,000 lines peak | ~2,000 lines peak | ~1,500 lines peak | 90% reduction |
| Agent count | 1 | 42 (21 gen + 21 review) | 21 (gen only) | Simpler workflow |
| Scalability | Limited by sequential | Limited by agent count | Limited by agent count | Scales horizontally |
| Failure isolation | One failure blocks all | Independent failures | Independent failures | Better resilience |
| Review overhead | N/A | ~6,300 lines flooding | 0 (separate command) | Eliminated bloat |

## When to Use Sequential vs. Parallel

**Use Parallel (v4 - this version):**
- Default for all doc generation
- When you have >3 docs to generate
- When speed matters
- When context window is limited

**Use Sequential (v3):**
- Debugging a specific doc (easier to trace)
- Very small projects (1-2 docs)
- When you need step-by-step control

**Rule of thumb:** Always prefer parallel unless you have a specific reason not to.
